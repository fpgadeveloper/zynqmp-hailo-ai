From 851bae91dbcbcac61b5e64ab111069106d96bf5e Mon Sep 17 00:00:00 2001
From: pankajd <pankajd@xilinx.com>
Date: Thu, 16 Sep 2021 23:19:03 -0600
Subject: [PATCH] Add support for cell size 4

Signed-off-by: pankajd <pankajd@xilinx.com>

This patch is a bit of a mess, the upstream files being patches are
a mix of LF and CRLF files.

Signed-off-by: Mark Hatle <mark.hatle@amd.com>
---
 src/Simd/SimdAvx2.h          |   2 +-
 src/Simd/SimdAvx2Hog.cpp     | 446 ++++++++++++++++++++++++++++++++--
 src/Simd/SimdAvx512bw.h      |   2 +-
 src/Simd/SimdAvx512bwHog.cpp | 442 ++++++++++++++++++++++++++++++++--
 src/Simd/SimdBase.h          |   2 +-
 src/Simd/SimdBaseHog.cpp     | 339 +++++++++++++++++++++++++-
 src/Simd/SimdLib.cpp         |  12 +-
 src/Simd/SimdLib.h           |   2 +-
 src/Simd/SimdNeon.h          |   2 +-
 src/Simd/SimdNeonHog.cpp     | 440 ++++++++++++++++++++++++++++++++--
 src/Simd/SimdSse41.h         |   2 +-
 src/Simd/SimdSse41Hog.cpp    | 451 +++++++++++++++++++++++++++++++++--
 12 files changed, 2049 insertions(+), 93 deletions(-)

diff --git a/src/Simd/SimdAvx2.h b/src/Simd/SimdAvx2.h
index 00910ce3..6f3771cc 100644
--- a/src/Simd/SimdAvx2.h
+++ b/src/Simd/SimdAvx2.h
@@ -227,7 +227,7 @@ namespace Simd
         void HogDirectionHistograms(const uint8_t * src, size_t stride, size_t width, size_t height,
             size_t cellX, size_t cellY, size_t quantization, float * histograms);
 
-        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features);
+        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len);
 
         void HogDeinterleave(const float * src, size_t srcStride, size_t width, size_t height, size_t count, float ** dst, size_t dstStride);
 
diff --git a/src/Simd/SimdAvx2Hog.cpp b/src/Simd/SimdAvx2Hog.cpp
index d62a9855..9547790b 100644
--- a/src/Simd/SimdAvx2Hog.cpp
+++ b/src/Simd/SimdAvx2Hog.cpp
@@ -401,9 +401,9 @@ namespace Simd
             }
         }
 
-        class HogFeatureExtractor
+        class HogFeatureExtractor4
         {
-            static const size_t C = 8;
+            static const size_t C = 4;
             static const size_t Q = 9;
             static const size_t Q2 = 18;
 
@@ -414,7 +414,7 @@ namespace Simd
 
             __m256i _pos[5];
             __m256 _cos[5], _sin[5];
-            __m128 _kx[8], _ky[8];
+            __m128 _kx[4], _ky[4];
             __m256i _Q, _Q2;
 
             Array32i _index;
@@ -436,7 +436,7 @@ namespace Simd
                 }
                 for (int i = 0; i < C; ++i)
                 {
-                    float k0 = float((15 - i * 2) / 16.0f);
+                    float k0 = float((7 - i * 2) / 8.0f);
                     float k1 = 1.0f - k0;
                     _kx[i] = _mm_setr_ps(k0, k1, k0, k1);
                     _ky[i] = _mm_setr_ps(k0, k0, k1, k1);
@@ -502,9 +502,9 @@ namespace Simd
                     GetHistogram<false>(s, stride, col);
                 GetHistogram<false>(s, stride, width - 1 - HA);
 
-                __m128 ky = _ky[(row + 4) & 7];
+                __m128 ky = _ky[(row + 2) & 3];
                 __m128 * buffer = (__m128*)_buffer.data;
-                for (size_t col = 1, n = C, i = 5; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))
+                for (size_t col = 1, n = C, i = 3; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))
                 {
                     for (; i < n; ++i, ++col)
                     {
@@ -563,16 +563,16 @@ namespace Simd
                 size_t aligned = AlignHi(width - 1, HA) - HA;
 
                 _buffer.Clear();
-                for (size_t row = 1; row < 4; ++row)
+                for (size_t row = 1; row < 2; ++row)
                     AddRowToBuffer(src, stride, row, width, aligned);
                 AddToHistogram(0, _sx, _sy);
-                for (size_t row = 4, cell = 1; row < height - 4; ++row)
+                for (size_t row = 2, cell = 1; row < height - 2; ++row)
                 {
                     AddRowToBuffer(src, stride, row, width, aligned);
-                    if ((row & 7) == 3)
+                    if ((row & 3) == 1)
                         AddToHistogram(cell++, _sx, _sy);
                 }
-                for (size_t row = height - 4; row < height - 1; ++row)
+                for (size_t row = height - 2; row < height - 1; ++row)
                     AddRowToBuffer(src, stride, row, width, aligned);
                 AddToHistogram(_sy, _sx, _sy);
             }
@@ -672,9 +672,63 @@ namespace Simd
                 }
             }
 
+			void ExtractFeatures22(float * features)
+			{
+				__m128 _02 = _mm_set1_ps(0.2f);
+				__m128 _05 = _mm_set1_ps(0.5f);
+				__m128 _02357 = _mm_set1_ps(0.2357f);
+				__m128 eps = _mm_set1_ps(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 22;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						__m128 n = _mm_setr_ps(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = _mm_rsqrt_ps(_mm_add_ps(n, eps));
+
+						__m128 t = _mm_setzero_ps();
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							__m128 s = _mm_loadu_ps(src);
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<3>(s), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(_mm_add_ps(h0, h1), _mm_add_ps(h2, h3)));
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(h0, h1));
+							__m128 h = _mm_hadd_ps(h0, h1);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(h, h)));
+							dst += 2;
+						}
+
+						_mm_storeu_ps(dst, _mm_mul_ps(t, _02357));
+					}
+				}
+			}
+
         public:
 
-            void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
+            void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int fet_len)
             {
                 Init(width, height);
 
@@ -682,17 +736,371 @@ namespace Simd
 
                 EstimateNorm();
 
-                ExtractFeatures(features);
+				if(fet_len == 31)
+					ExtractFeatures(features);
+				else
+					ExtractFeatures22(features);
             }
         };
 
-        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
-        {
-            assert(width % 8 == 0 && height % 8 == 0 && width >= 16 && height >= 16);
-            assert(width >= HA + 2);
-
-            HogFeatureExtractor extractor;
-            extractor.Run(src, stride, width, height, features);
+		class HogFeatureExtractor
+		{
+			static const size_t C = 8;
+			static const size_t Q = 9;
+			static const size_t Q2 = 18;
+
+			typedef Array<int> Array32i;
+			typedef Array<float> Array32f;
+
+			size_t _sx, _sy, _hs;
+
+			__m256i _pos[5];
+			__m256 _cos[5], _sin[5];
+			__m128 _kx[8], _ky[8];
+			__m256i _Q, _Q2;
+
+			Array32i _index;
+			Array32f _value;
+			Array32f _buffer;
+			Array32f _histogram;
+			Array32f _norm;
+
+			void Init(size_t w, size_t h)
+			{
+				_sx = w / C;
+				_hs = _sx + 2;
+				_sy = h / C;
+				for (int i = 0; i < 5; ++i)
+				{
+					_cos[i] = _mm256_set1_ps((float)::cos(i*M_PI / Q));
+					_sin[i] = _mm256_set1_ps((float)::sin(i*M_PI / Q));
+					_pos[i] = _mm256_set1_epi32(i);
+				}
+				for (int i = 0; i < C; ++i)
+				{
+					float k0 = float((15 - i * 2) / 16.0f);
+					float k1 = 1.0f - k0;
+					_kx[i] = _mm_setr_ps(k0, k1, k0, k1);
+					_ky[i] = _mm_setr_ps(k0, k0, k1, k1);
+				}
+				_Q = _mm256_set1_epi32(Q);
+				_Q2 = _mm256_set1_epi32(Q2);
+
+				_index.Resize(w);
+				_value.Resize(w);
+				_buffer.Resize((_sx + 1) * 4 * Q2);
+				_histogram.Resize((_sx + 2)*(_sy + 2)*Q2);
+				_norm.Resize((_sx + 2)*(_sy + 2));
+			}
+
+			template <bool align> SIMD_INLINE void GetHistogram(const __m256 & dx, const __m256 & dy, size_t col)
+			{
+				__m256 _0 = _mm256_set1_ps(-0.0f);
+				__m256 adx = _mm256_andnot_ps(_0, dx);
+				__m256 ady = _mm256_andnot_ps(_0, dy);
+				__m256 bestDot = _mm256_fmadd_ps(adx, _cos[0], _mm256_mul_ps(ady, _sin[0]));
+				__m256i bestIndex = _pos[0];
+				for (int i = 1; i < 5; ++i)
+				{
+					__m256 dot = _mm256_fmadd_ps(adx, _cos[i], _mm256_mul_ps(ady, _sin[i]));
+					__m256 mask = _mm256_cmp_ps(dot, bestDot, _CMP_GT_OS);
+					bestDot = _mm256_max_ps(dot, bestDot);
+					bestIndex = _mm256_blendv_epi8(bestIndex, _pos[i], _mm256_castps_si256(mask));
+				}
+				__m256i maskDx = _mm256_castps_si256(_mm256_cmp_ps(dx, _mm256_setzero_ps(), _CMP_LT_OS));
+				bestIndex = _mm256_blendv_epi8(bestIndex, _mm256_sub_epi32(_Q, bestIndex), maskDx);
+
+				__m256i maskDy = _mm256_castps_si256(_mm256_cmp_ps(dy, _mm256_setzero_ps(), _CMP_LT_OS));
+				__m256i corr = _mm256_and_si256(_mm256_castps_si256(_mm256_cmp_ps(adx, _mm256_setzero_ps(), _CMP_EQ_OS)), K32_00000001);
+				bestIndex = _mm256_blendv_epi8(bestIndex, _mm256_sub_epi32(_Q2, _mm256_add_epi32(bestIndex, corr)), maskDy);
+
+				bestIndex = _mm256_andnot_si256(_mm256_cmpeq_epi32(bestIndex, _Q2), bestIndex);
+
+				Store<align>((__m256i*)(_index.data + col), bestIndex);
+				Avx::Store<align>(_value.data + col, Avx::Sqrt<0>(_mm256_fmadd_ps(adx, adx, _mm256_mul_ps(ady, ady))));
+			}
+
+			template <int part> SIMD_INLINE __m256 ConvertDifference(const __m128i & a, const __m128i & b)
+			{
+				return _mm256_cvtepi32_ps(_mm256_cvtepi16_epi32(Ssse3::SubUnpackedU8<part>(a, b)));
+			}
+
+			template <bool align> SIMD_INLINE void GetHistogram(const uint8_t * src, size_t stride, size_t col)
+			{
+				const uint8_t * s = src + col;
+				__m128i t = Sse2::Load<false>((__m128i*)(s - stride));
+				__m128i l = Sse2::Load<false>((__m128i*)(s - 1));
+				__m128i r = Sse2::Load<false>((__m128i*)(s + 1));
+				__m128i b = Sse2::Load<false>((__m128i*)(s + stride));
+				GetHistogram<align>(ConvertDifference<0>(r, l), ConvertDifference<0>(b, t), col + 0);
+				GetHistogram<align>(ConvertDifference<1>(r, l), ConvertDifference<1>(b, t), col + 8);
+			}
+
+			void AddRowToBuffer(const uint8_t * src, size_t stride, size_t row, size_t width, size_t aligned)
+			{
+				const uint8_t * s = src + stride * row;
+				GetHistogram<false>(s, stride, 1);
+				for (size_t col = HA; col < aligned; col += HA)
+					GetHistogram<false>(s, stride, col);
+				GetHistogram<false>(s, stride, width - 1 - HA);
+
+				__m128 ky = _ky[(row + 4) & 7];
+				__m128 * buffer = (__m128*)_buffer.data;
+				for (size_t col = 1, n = C, i = 5; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))
+				{
+					for (; i < n; ++i, ++col)
+					{
+						int index = _index[col];
+						__m128 value = _mm_set1_ps(_value[col]);
+						buffer[index] = _mm_fmadd_ps(_mm_mul_ps(ky, _kx[i]), value, buffer[index]);
+					}
+					buffer += Q2;
+				}
+			}
+
+			void AddToHistogram(size_t row, size_t width, size_t height)
+			{
+				typedef float f18_t[18];
+
+				float * src = _buffer.data;
+				f18_t * h0 = (f18_t*)_histogram.data + row * _hs;
+				f18_t * h1 = h0 + _hs;
+
+				for (size_t cell = 0; cell <= width; ++cell)
+				{
+					for (size_t i = 0; i < 16; i += F)
+					{
+						const float * s = src + i * 4;
+						__m256 a0 = Avx::Load<true>(s + 0x00, s + 0x10);
+						__m256 a1 = Avx::Load<true>(s + 0x04, s + 0x14);
+						__m256 a2 = Avx::Load<true>(s + 0x08, s + 0x18);
+						__m256 a3 = Avx::Load<true>(s + 0x0C, s + 0x1C);
+						__m256 b0 = _mm256_unpacklo_ps(a0, a2);
+						__m256 b1 = _mm256_unpackhi_ps(a0, a2);
+						__m256 b2 = _mm256_unpacklo_ps(a1, a3);
+						__m256 b3 = _mm256_unpackhi_ps(a1, a3);
+						Avx::Store<false>(h0[0] + i, _mm256_add_ps(Avx::Load<false>(h0[0] + i), _mm256_unpacklo_ps(b0, b2)));
+						Avx::Store<false>(h0[1] + i, _mm256_add_ps(Avx::Load<false>(h0[1] + i), _mm256_unpackhi_ps(b0, b2)));
+						Avx::Store<false>(h1[0] + i, _mm256_add_ps(Avx::Load<false>(h1[0] + i), _mm256_unpacklo_ps(b1, b3)));
+						Avx::Store<false>(h1[1] + i, _mm256_add_ps(Avx::Load<false>(h1[1] + i), _mm256_unpackhi_ps(b1, b3)));
+					}
+					__m128 * ps = (__m128*)src;
+					__m128 s0 = _mm_add_ps(_mm_unpacklo_ps(ps[16], ps[17]), Sse::Load(h0[0] + 16, h0[1] + 16));
+					__m128 s1 = _mm_add_ps(_mm_unpackhi_ps(ps[16], ps[17]), Sse::Load(h1[0] + 16, h1[1] + 16));
+					Sse::StoreHalf<0>(h0[0] + 16, s0);
+					Sse::StoreHalf<1>(h0[1] + 16, s0);
+					Sse::StoreHalf<0>(h1[0] + 16, s1);
+					Sse::StoreHalf<1>(h1[1] + 16, s1);
+					h0++;
+					h1++;
+					src += 72;
+				}
+				_buffer.Clear();
+			}
+
+			void EstimateHistogram(const uint8_t * src, size_t stride, size_t width, size_t height)
+			{
+				_histogram.Clear();
+
+				size_t aligned = AlignHi(width - 1, HA) - HA;
+
+				_buffer.Clear();
+				for (size_t row = 1; row < 4; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(0, _sx, _sy);
+				for (size_t row = 4, cell = 1; row < height - 4; ++row)
+				{
+					AddRowToBuffer(src, stride, row, width, aligned);
+					if ((row & 7) == 3)
+						AddToHistogram(cell++, _sx, _sy);
+				}
+				for (size_t row = height - 4; row < height - 1; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(_sy, _sx, _sy);
+			}
+
+			SIMD_INLINE float GetNorm(const float * src)
+			{
+				__m256 norm = _mm256_add_ps(_mm256_loadu_ps(src), _mm256_loadu_ps(src + Q));
+				norm = _mm256_mul_ps(norm, norm);
+				norm = _mm256_hadd_ps(norm, norm);
+				norm = _mm256_hadd_ps(norm, norm);
+				float buf[8];
+				_mm256_storeu_ps(buf, norm);
+				return buf[0] + buf[4] + Simd::Square(src[Q - 1] + src[Q2 - 1]);
+			}
+
+			void EstimateNorm()
+			{
+				_norm.Clear();
+				for (size_t y = 0, i = 0; y < _sy; y++)
+				{
+					const float * h = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					float * n = _norm.data + (y + 1)*_hs + 1;
+					for (size_t x = 0; x < _sx; x++, i++)
+						n[x] = GetNorm(h + x * Q2);
+				}
+			}
+
+			void ExtractFeatures(float * features)
+			{
+				__m128 _02 = _mm_set1_ps(0.2f);
+				__m128 _05 = _mm_set1_ps(0.5f);
+				__m128 _02357 = _mm_set1_ps(0.2357f);
+				__m128 eps = _mm_set1_ps(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 31;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						__m128 n = _mm_setr_ps(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = _mm_rsqrt_ps(_mm_add_ps(n, eps));
+
+						__m128 t = _mm_setzero_ps();
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							__m128 s = _mm_loadu_ps(src);
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<3>(s), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(_mm_add_ps(h0, h1), _mm_add_ps(h2, h3)));
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(h0, h1));
+							__m128 h = _mm_hadd_ps(h0, h1);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(h, h)));
+							dst += 2;
+						}
+
+						src = ph + x * Q2;
+						for (int o = 0; o < 8; o += 4)
+						{
+							__m128 s = _mm_add_ps(_mm_loadu_ps(src), _mm_loadu_ps(src + Q));
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<3>(s), n), _02);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 s = _mm_set1_ps(src[0] + src[Q]);
+							__m128 h = _mm_min_ps(_mm_mul_ps(s, n), _02);
+							h = _mm_dp_ps(_05, h, 0xF1);
+							_mm_store_ss(dst++, h);
+						}
+						_mm_storeu_ps(dst, _mm_mul_ps(t, _02357));
+					}
+				}
+			}
+
+			void ExtractFeatures22(float * features)
+			{
+				__m128 _02 = _mm_set1_ps(0.2f);
+				__m128 _05 = _mm_set1_ps(0.5f);
+				__m128 _02357 = _mm_set1_ps(0.2357f);
+				__m128 eps = _mm_set1_ps(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 22;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						__m128 n = _mm_setr_ps(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = _mm_rsqrt_ps(_mm_add_ps(n, eps));
+
+						__m128 t = _mm_setzero_ps();
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							__m128 s = _mm_loadu_ps(src);
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<3>(s), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(_mm_add_ps(h0, h1), _mm_add_ps(h2, h3)));
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(h0, h1));
+							__m128 h = _mm_hadd_ps(h0, h1);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(h, h)));
+							dst += 2;
+						}
+
+						_mm_storeu_ps(dst, _mm_mul_ps(t, _02357));
+					}
+				}
+			}
+
+		public:
+
+			void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int fet_len)
+			{
+				Init(width, height);
+
+				EstimateHistogram(src, stride, width, height);
+
+				EstimateNorm();
+
+				if(fet_len == 31)
+					ExtractFeatures(features);
+				else
+					ExtractFeatures22(features);
+			}
+		};
+
+		void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len)
+		{
+			if (cell_size == 8){
+				assert(width % cell_size == 0 && height % cell_size == 0 && width >= 16 && height >= 16);
+				assert(width >= HA + 2);
+
+				HogFeatureExtractor extractor;
+				extractor.Run(src, stride, width, height, features, fet_len);
+			}
+			else if (cell_size == 4) {
+				assert(width % cell_size == 0 && height % cell_size == 0 && width >= 16 && height >= 16);
+				assert(width >= HA + 2);
+
+				HogFeatureExtractor4 extractor;
+				extractor.Run(src, stride, width, height, features, fet_len);
+			}
         }
 
         SIMD_INLINE void HogDeinterleave(const float * src, size_t count, float ** dst, size_t offset, size_t i)
diff --git a/src/Simd/SimdAvx512bw.h b/src/Simd/SimdAvx512bw.h
index 1c7e824a..3aa62b18 100644
--- a/src/Simd/SimdAvx512bw.h
+++ b/src/Simd/SimdAvx512bw.h
@@ -218,7 +218,7 @@ namespace Simd
         void HogDirectionHistograms(const uint8_t * src, size_t stride, size_t width, size_t height,
             size_t cellX, size_t cellY, size_t quantization, float * histograms);
 
-        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features);
+        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len);
 
         void HogDeinterleave(const float * src, size_t srcStride, size_t width, size_t height, size_t count, float ** dst, size_t dstStride);
 
diff --git a/src/Simd/SimdAvx512bwHog.cpp b/src/Simd/SimdAvx512bwHog.cpp
index 60b61eef..fe96e0b4 100644
--- a/src/Simd/SimdAvx512bwHog.cpp
+++ b/src/Simd/SimdAvx512bwHog.cpp
@@ -379,9 +379,9 @@ namespace Simd
             }
         }
 
-        class HogFeatureExtractor
+        class HogFeatureExtractor4
         {
-            static const size_t C = 8;
+            static const size_t C = 4;
             static const size_t Q = 9;
             static const size_t Q2 = 18;
 
@@ -392,7 +392,7 @@ namespace Simd
 
             __m512i _pos[5];
             __m512 _cos[5], _sin[5];
-            __m128 _kx[8], _ky[8];
+            __m128 _kx[4], _ky[4];
             __m512i _Q, _Q2;
 
             Array32i _index;
@@ -414,7 +414,7 @@ namespace Simd
                 }
                 for (int i = 0; i < C; ++i)
                 {
-                    float k0 = float((15 - i * 2) / 16.0f);
+                    float k0 = float((7 - i * 2) / 8.0f);
                     float k1 = 1.0f - k0;
                     _kx[i] = _mm_setr_ps(k0, k1, k0, k1);
                     _ky[i] = _mm_setr_ps(k0, k0, k1, k1);
@@ -472,9 +472,9 @@ namespace Simd
                     GetHistogram<false>(s, stride, col);
                 GetHistogram<false>(s, stride, width - 1 - HA);
 
-                __m128 ky = _ky[(row + 4) & 7];
+                __m128 ky = _ky[(row + 2) & 3];
                 __m128 * buffer = (__m128*)_buffer.data;
-                for (size_t col = 1, n = C, i = 5; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))
+                for (size_t col = 1, n = C, i = 3; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))
                 {
                     for (; i < n; ++i, ++col)
                     {
@@ -539,16 +539,16 @@ namespace Simd
                 size_t aligned = AlignHi(width - 1, HA) - HA;
 
                 _buffer.Clear();
-                for (size_t row = 1; row < 4; ++row)
+                for (size_t row = 1; row < 2; ++row)
                     AddRowToBuffer(src, stride, row, width, aligned);
                 AddToHistogram(0, _sx, _sy);
-                for (size_t row = 4, cell = 1; row < height - 4; ++row)
+                for (size_t row = 2, cell = 1; row < height - 2; ++row)
                 {
                     AddRowToBuffer(src, stride, row, width, aligned);
-                    if ((row & 7) == 3)
+                    if ((row & 3) == 1)
                         AddToHistogram(cell++, _sx, _sy);
                 }
-                for (size_t row = height - 4; row < height - 1; ++row)
+                for (size_t row = height - 2; row < height - 1; ++row)
                     AddRowToBuffer(src, stride, row, width, aligned);
                 AddToHistogram(_sy, _sx, _sy);
             }
@@ -648,9 +648,63 @@ namespace Simd
                 }
             }
 
+			void ExtractFeatures22(float * features)
+			{
+				__m128 _02 = _mm_set1_ps(0.2f);
+				__m128 _05 = _mm_set1_ps(0.5f);
+				__m128 _02357 = _mm_set1_ps(0.2357f);
+				__m128 eps = _mm_set1_ps(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 22;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						__m128 n = _mm_setr_ps(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = _mm_rsqrt_ps(_mm_add_ps(n, eps));
+
+						__m128 t = _mm_setzero_ps();
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							__m128 s = _mm_loadu_ps(src);
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<3>(s), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(_mm_add_ps(h0, h1), _mm_add_ps(h2, h3)));
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(h0, h1));
+							__m128 h = _mm_hadd_ps(h0, h1);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(h, h)));
+							dst += 2;
+						}
+
+						_mm_storeu_ps(dst, _mm_mul_ps(t, _02357));
+					}
+				}
+			}
+
         public:
 
-            void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
+            void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int fet_len)
             {
                 Init(width, height);
 
@@ -658,17 +712,369 @@ namespace Simd
 
                 EstimateNorm();
 
-                ExtractFeatures(features);
+				if(fet_len == 31)
+					ExtractFeatures(features);
+				else
+					ExtractFeatures22(features);
             }
         };
 
-        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
+		class HogFeatureExtractor
+		{
+			static const size_t C = 8;
+			static const size_t Q = 9;
+			static const size_t Q2 = 18;
+
+			typedef Array<int> Array32i;
+			typedef Array<float> Array32f;
+
+			size_t _sx, _sy, _hs;
+
+			__m512i _pos[5];
+			__m512 _cos[5], _sin[5];
+			__m128 _kx[8], _ky[8];
+			__m512i _Q, _Q2;
+
+			Array32i _index;
+			Array32f _value;
+			Array32f _buffer;
+			Array32f _histogram;
+			Array32f _norm;
+
+			void Init(size_t w, size_t h)
+			{
+				_sx = w / C;
+				_hs = _sx + 2;
+				_sy = h / C;
+				for (int i = 0; i < 5; ++i)
+				{
+					_cos[i] = _mm512_set1_ps((float)::cos(i*M_PI / Q));
+					_sin[i] = _mm512_set1_ps((float)::sin(i*M_PI / Q));
+					_pos[i] = _mm512_set1_epi32(i);
+				}
+				for (int i = 0; i < C; ++i)
+				{
+					float k0 = float((15 - i * 2) / 16.0f);
+					float k1 = 1.0f - k0;
+					_kx[i] = _mm_setr_ps(k0, k1, k0, k1);
+					_ky[i] = _mm_setr_ps(k0, k0, k1, k1);
+				}
+				_Q = _mm512_set1_epi32(Q);
+				_Q2 = _mm512_set1_epi32(Q2);
+
+				_index.Resize(w);
+				_value.Resize(w);
+				_buffer.Resize((_sx + 1) * 4 * Q2);
+				_histogram.Resize((_sx + 2)*(_sy + 2)*Q2);
+				_norm.Resize((_sx + 2)*(_sy + 2));
+			}
+
+			template <bool align> SIMD_INLINE void GetHistogram(const __m512 & dx, const __m512 & dy, size_t col)
+			{
+				__m512 _0 = _mm512_set1_ps(-0.0f);
+				__m512 adx = _mm512_andnot_ps(_0, dx);
+				__m512 ady = _mm512_andnot_ps(_0, dy);
+				__m512 bestDot = _mm512_fmadd_ps(adx, _cos[0], _mm512_mul_ps(ady, _sin[0]));
+				__m512i bestIndex = _pos[0];
+				for (int i = 1; i < 5; ++i)
+				{
+					__m512 dot = _mm512_fmadd_ps(adx, _cos[i], _mm512_mul_ps(ady, _sin[i]));
+					bestIndex = _mm512_mask_blend_epi32(_mm512_cmp_ps_mask(dot, bestDot, _CMP_GT_OS), bestIndex, _pos[i]);
+					bestDot = _mm512_max_ps(dot, bestDot);
+				}
+				bestIndex = _mm512_mask_sub_epi32(bestIndex, _mm512_cmp_ps_mask(dx, _0, _CMP_LT_OS), _Q, bestIndex);
+
+				__m512i corr = _mm512_maskz_set1_epi32(_mm512_cmp_ps_mask(adx, _mm512_setzero_ps(), _CMP_EQ_OS), 1);
+				bestIndex = _mm512_mask_sub_epi32(bestIndex, _mm512_cmp_ps_mask(dy, _0, _CMP_LT_OS), _Q2, _mm512_add_epi32(bestIndex, corr));
+
+				bestIndex = _mm512_mask_set1_epi32(bestIndex, _mm512_cmpeq_epi32_mask(bestIndex, _Q2), 0);
+
+				Store<align>(_index.data + col, bestIndex);
+				Avx512f::Store<align>(_value.data + col, _mm512_sqrt_ps(_mm512_fmadd_ps(adx, adx, _mm512_mul_ps(ady, ady))));
+			}
+
+			template <bool align> SIMD_INLINE void GetHistogram(const uint8_t * src, size_t stride, size_t col)
+			{
+				const uint8_t * s = src + col;
+				__m256i t = Avx2::LoadPermuted<false>((__m256i*)(s - stride));
+				__m256i l = Avx2::LoadPermuted<false>((__m256i*)(s - 1));
+				__m256i r = Avx2::LoadPermuted<false>((__m256i*)(s + 1));
+				__m256i b = Avx2::LoadPermuted<false>((__m256i*)(s + stride));
+				GetHistogram<align>(CovertDifference<0>(r, l), CovertDifference<0>(b, t), col + 0);
+				GetHistogram<align>(CovertDifference<1>(r, l), CovertDifference<1>(b, t), col + F);
+			}
+
+			void AddRowToBuffer(const uint8_t * src, size_t stride, size_t row, size_t width, size_t aligned)
+			{
+				const uint8_t * s = src + stride * row;
+				GetHistogram<false>(s, stride, 1);
+				for (size_t col = HA; col < aligned; col += HA)
+					GetHistogram<false>(s, stride, col);
+				GetHistogram<false>(s, stride, width - 1 - HA);
+
+				__m128 ky = _ky[(row + 4) & 7];
+				__m128 * buffer = (__m128*)_buffer.data;
+				for (size_t col = 1, n = C, i = 5; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))
+				{
+					for (; i < n; ++i, ++col)
+					{
+						int index = _index[col];
+						__m128 value = _mm_set1_ps(_value[col]);
+						buffer[index] = _mm_fmadd_ps(_mm_mul_ps(ky, _kx[i]), value, buffer[index]);
+					}
+					buffer += Q2;
+				}
+			}
+
+			void AddToHistogram(size_t row, size_t width, size_t height)
+			{
+				typedef float f18_t[18];
+
+				float * src = _buffer.data;
+				f18_t * h0 = (f18_t*)_histogram.data + row * _hs;
+				f18_t * h1 = h0 + _hs;
+
+				for (size_t cell = 0; cell <= width; ++cell)
+				{
+					__m512 a0 = Load<true>(src + 0x00, src + 0x10, src + 0x20, src + 0x30);
+					__m512 a1 = Load<true>(src + 0x04, src + 0x14, src + 0x24, src + 0x34);
+					__m512 a2 = Load<true>(src + 0x08, src + 0x18, src + 0x28, src + 0x38);
+					__m512 a3 = Load<true>(src + 0x0C, src + 0x1C, src + 0x2C, src + 0x3C);
+					__m512 b0 = _mm512_unpacklo_ps(a0, a2);
+					__m512 b1 = _mm512_unpackhi_ps(a0, a2);
+					__m512 b2 = _mm512_unpacklo_ps(a1, a3);
+					__m512 b3 = _mm512_unpackhi_ps(a1, a3);
+					Avx512f::Store<false>(h0[0], _mm512_add_ps(Avx512f::Load<false>(h0[0]), _mm512_unpacklo_ps(b0, b2)));
+					Avx512f::Store<false>(h0[1], _mm512_add_ps(Avx512f::Load<false>(h0[1]), _mm512_unpackhi_ps(b0, b2)));
+					Avx512f::Store<false>(h1[0], _mm512_add_ps(Avx512f::Load<false>(h1[0]), _mm512_unpacklo_ps(b1, b3)));
+					Avx512f::Store<false>(h1[1], _mm512_add_ps(Avx512f::Load<false>(h1[1]), _mm512_unpackhi_ps(b1, b3)));
+#if defined(_MSC_VER)
+					for (size_t i = 16; i < 18; ++i)
+					{
+						h0[0][i] += src[i * 4 + 0];
+						h0[1][i] += src[i * 4 + 1];
+						h1[0][i] += src[i * 4 + 2];
+						h1[1][i] += src[i * 4 + 3];
+					}
+#else
+					__m128 * ps = (__m128*)src;
+					__m128 s0 = _mm_add_ps(_mm_unpacklo_ps(ps[16], ps[17]), Sse::Load(h0[0] + 16, h0[1] + 16));
+					__m128 s1 = _mm_add_ps(_mm_unpackhi_ps(ps[16], ps[17]), Sse::Load(h1[0] + 16, h1[1] + 16));
+					Sse::StoreHalf<0>(h0[0] + 16, s0);
+					Sse::StoreHalf<1>(h0[1] + 16, s0);
+					Sse::StoreHalf<0>(h1[0] + 16, s1);
+					Sse::StoreHalf<1>(h1[1] + 16, s1);
+#endif
+					h0++;
+					h1++;
+					src += 72;
+				}
+				_buffer.Clear();
+			}
+
+			void EstimateHistogram(const uint8_t * src, size_t stride, size_t width, size_t height)
+			{
+				_histogram.Clear();
+
+				size_t aligned = AlignHi(width - 1, HA) - HA;
+
+				_buffer.Clear();
+				for (size_t row = 1; row < 4; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(0, _sx, _sy);
+				for (size_t row = 4, cell = 1; row < height - 4; ++row)
+				{
+					AddRowToBuffer(src, stride, row, width, aligned);
+					if ((row & 7) == 3)
+						AddToHistogram(cell++, _sx, _sy);
+				}
+				for (size_t row = height - 4; row < height - 1; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(_sy, _sx, _sy);
+			}
+
+			SIMD_INLINE float GetNorm(const float * src)
+			{
+				__m256 norm = _mm256_add_ps(_mm256_loadu_ps(src), _mm256_loadu_ps(src + Q));
+				norm = _mm256_mul_ps(norm, norm);
+				norm = _mm256_hadd_ps(norm, norm);
+				norm = _mm256_hadd_ps(norm, norm);
+				float buf[8];
+				_mm256_storeu_ps(buf, norm);
+				return buf[0] + buf[4] + Simd::Square(src[Q - 1] + src[Q2 - 1]);
+			}
+
+			void EstimateNorm()
+			{
+				_norm.Clear();
+				for (size_t y = 0, i = 0; y < _sy; y++)
+				{
+					const float * h = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					float * n = _norm.data + (y + 1)*_hs + 1;
+					for (size_t x = 0; x < _sx; x++, i++)
+						n[x] = GetNorm(h + x * Q2);
+				}
+			}
+
+			void ExtractFeatures(float * features)
+			{
+				__m128 _02 = _mm_set1_ps(0.2f);
+				__m128 _05 = _mm_set1_ps(0.5f);
+				__m128 _02357 = _mm_set1_ps(0.2357f);
+				__m128 eps = _mm_set1_ps(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 31;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						__m128 n = _mm_setr_ps(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = _mm_rsqrt_ps(_mm_add_ps(n, eps));
+
+						__m128 t = _mm_setzero_ps();
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							__m128 s = _mm_loadu_ps(src);
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<3>(s), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(_mm_add_ps(h0, h1), _mm_add_ps(h2, h3)));
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(h0, h1));
+							__m128 h = _mm_hadd_ps(h0, h1);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(h, h)));
+							dst += 2;
+						}
+
+						src = ph + x * Q2;
+						for (int o = 0; o < 8; o += 4)
+						{
+							__m128 s = _mm_add_ps(_mm_loadu_ps(src), _mm_loadu_ps(src + Q));
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<3>(s), n), _02);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 s = _mm_set1_ps(src[0] + src[Q]);
+							__m128 h = _mm_min_ps(_mm_mul_ps(s, n), _02);
+							h = _mm_dp_ps(_05, h, 0xF1);
+							_mm_store_ss(dst++, h);
+						}
+						_mm_storeu_ps(dst, _mm_mul_ps(t, _02357));
+					}
+				}
+			}
+
+			void ExtractFeatures22(float * features)
+			{
+				__m128 _02 = _mm_set1_ps(0.2f);
+				__m128 _05 = _mm_set1_ps(0.5f);
+				__m128 _02357 = _mm_set1_ps(0.2357f);
+				__m128 eps = _mm_set1_ps(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 22;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						__m128 n = _mm_setr_ps(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = _mm_rsqrt_ps(_mm_add_ps(n, eps));
+
+						__m128 t = _mm_setzero_ps();
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							__m128 s = _mm_loadu_ps(src);
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Sse2::Broadcast<3>(s), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(_mm_add_ps(h0, h1), _mm_add_ps(h2, h3)));
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(h0, h1));
+							__m128 h = _mm_hadd_ps(h0, h1);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(h, h)));
+							dst += 2;
+						}
+
+						_mm_storeu_ps(dst, _mm_mul_ps(t, _02357));
+					}
+				}
+			}
+
+		public:
+
+			void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int fet_len)
+			{
+				Init(width, height);
+
+				EstimateHistogram(src, stride, width, height);
+
+				EstimateNorm();
+
+				if(fet_len == 31)
+					ExtractFeatures(features);
+				else
+					ExtractFeatures22(features);
+			}
+		};
+
+        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len)
         {
-            assert(width % 8 == 0 && height % 8 == 0 && width >= 16 && height >= 16);
-            assert(width >= HA + 2);
-
-            HogFeatureExtractor extractor;
-            extractor.Run(src, stride, width, height, features);
+			if (cell_size == 8) {
+				assert(width % cell_size == 0 && height % cell_size == 0 && width >= 16 && height >= 16);
+				assert(width >= HA + 2);
+
+				HogFeatureExtractor extractor;
+				extractor.Run(src, stride, width, height, features, fet_len);
+			}
+			else if (cell_size == 4) {
+				assert(width % cell_size == 0 && height % cell_size == 0 && width >= 16 && height >= 16);
+				assert(width >= HA + 2);
+
+				HogFeatureExtractor4 extractor;
+				extractor.Run(src, stride, width, height, features, fet_len);
+			}
         }
 
         SIMD_INLINE void HogDeinterleave(const float * src, size_t count, float ** dst, size_t offset, size_t i)
diff --git a/src/Simd/SimdBase.h b/src/Simd/SimdBase.h
index b52cb7bc..9df5306f 100644
--- a/src/Simd/SimdBase.h
+++ b/src/Simd/SimdBase.h
@@ -286,7 +286,7 @@ namespace Simd
         void HogDirectionHistograms(const uint8_t * src, size_t stride, size_t width, size_t height,
             size_t cellX, size_t cellY, size_t quantization, float * histograms);
 
-        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features);
+        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len);
 
         void HogDeinterleave(const float * src, size_t srcStride, size_t width, size_t height, size_t count, float ** dst, size_t dstStride);
 
diff --git a/src/Simd/SimdBaseHog.cpp b/src/Simd/SimdBaseHog.cpp
index fa26e4fe..64be441d 100644
--- a/src/Simd/SimdBaseHog.cpp
+++ b/src/Simd/SimdBaseHog.cpp
@@ -240,9 +240,9 @@ namespace Simd
             }
         }
 
-        class HogFeatureExtractor
+        class HogFeatureExtractor4
         {
-            static const size_t C = 8;
+	    static const size_t C = 4; //8; //adhi
             static const size_t Q = 9;
             static const size_t Q2 = 18;
 
@@ -268,7 +268,7 @@ namespace Simd
                     _sin[i] = (float)::sin(i*M_PI / Q);
                 }
                 for (int i = 0; i < C; ++i)
-                    _k[i] = float((1 + i * 2) / 16.0f);
+                    _k[i] = float((1 + i * 2) / 8.0f); //adhi 16 t0 8
                 _index.Resize(w);
                 _value.Resize(w);
                 _histogram.Resize((_sx + 2)*(_sy + 2)*Q2);
@@ -277,12 +277,12 @@ namespace Simd
 
             void AddRowToHistogram(size_t row, size_t width, size_t height)
             {
-                size_t iyp = (row - 4) / C;
-                float vy0 = _k[(row + 4) & 7];
+                size_t iyp = (row - 2) / C; //adhi 4 to 2
+                float vy0 = _k[(row + 2) & 3]; //adhi 4 to 2 and 7 to 3
                 float vy1 = 1.0f - vy0;
                 float * h0 = _histogram.data + ((iyp + 1)*_hs + 0)*Q2;
                 float * h1 = _histogram.data + ((iyp + 2)*_hs + 0)*Q2;
-                for (size_t col = 1, n = C, i = 5; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))
+                for (size_t col = 1, n = C, i = 3; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1)) //adhi i = 5 to 3
                 {
                     for (; i < n; ++i, ++col)
                     {
@@ -422,8 +422,60 @@ namespace Simd
                 }
             }
 
+			void ExtractFeatures22(float * features)
+			{
+				float eps = 0.0001f;
+				for (size_t y = 0; y < _sy; y++)
+				{
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 22;
+
+						float *psrc, n1, n2, n3, n4;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						n1 = 1.0f / sqrt(p1[1] + p1[2] + p2[1] + p2[2] + eps);
+						n2 = 1.0f / sqrt(p0[1] + p0[2] + p1[1] + p1[2] + eps);
+						n3 = 1.0f / sqrt(p1[0] + p1[1] + p2[0] + p2[1] + eps);
+						n4 = 1.0f / sqrt(p0[0] + p0[1] + p1[0] + p1[1] + eps);
+
+						float t1 = 0;
+						float t2 = 0;
+						float t3 = 0;
+						float t4 = 0;
+
+						psrc = _histogram.data + ((y + 1)*_hs + x + 1)*Q2;
+						for (int o = 0; o < Q2; o++)
+						{
+							float h1 = Simd::Min(*psrc * n1, 0.2f);
+							float h2 = Simd::Min(*psrc * n2, 0.2f);
+							float h3 = Simd::Min(*psrc * n3, 0.2f);
+							float h4 = Simd::Min(*psrc * n4, 0.2f);
+							*dst = 0.5f * (h1 + h2 + h3 + h4);
+							t1 += h1;
+							t2 += h2;
+							t3 += h3;
+							t4 += h4;
+							dst++;
+							psrc++;
+						}
+
+						*dst = 0.2357f * t1;
+						dst++;
+						*dst = 0.2357f * t2;
+						dst++;
+						*dst = 0.2357f * t3;
+						dst++;
+						*dst = 0.2357f * t4;
+					}
+				}
+			}
+
         public:
-            void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
+            void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int fet_len)
             {
                 Init(width, height);
 
@@ -431,16 +483,277 @@ namespace Simd
 
                 EstimateNorm();
 
-                ExtractFeatures(features);
+				if (fet_len == 31)
+					ExtractFeatures(features);
+				else
+					ExtractFeatures22(features);
             }
         };
 
-        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
+		class HogFeatureExtractor
+		{
+			static const size_t C = 8; 
+			static const size_t Q = 9;
+			static const size_t Q2 = 18;
+
+			size_t _sx, _sy, _hs;
+
+			float _cos[5];
+			float _sin[5];
+			float _k[C];
+
+			Array32i _index;
+			Array32f _value;
+			Array32f _histogram;
+			Array32f _norm;
+
+			void Init(size_t w, size_t h)
+			{
+				_sx = w / C;
+				_hs = _sx + 2;
+				_sy = h / C;
+				for (int i = 0; i < 5; ++i)
+				{
+					_cos[i] = (float)::cos(i*M_PI / Q);
+					_sin[i] = (float)::sin(i*M_PI / Q);
+				}
+				for (int i = 0; i < C; ++i)
+					_k[i] = float((1 + i * 2) / 16.0f);
+				_index.Resize(w);
+				_value.Resize(w);
+				_histogram.Resize((_sx + 2)*(_sy + 2)*Q2);
+				_norm.Resize((_sx + 2)*(_sy + 2));
+			}
+
+			void AddRowToHistogram(size_t row, size_t width, size_t height)
+			{
+				size_t iyp = (row - 4) / C; 
+				float vy0 = _k[(row + 4) & 7];
+				float vy1 = 1.0f - vy0;
+				float * h0 = _histogram.data + ((iyp + 1)*_hs + 0)*Q2;
+				float * h1 = _histogram.data + ((iyp + 2)*_hs + 0)*Q2;
+				for (size_t col = 1, n = C, i = 5; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1)) 
+				{
+					for (; i < n; ++i, ++col)
+					{
+						float value = _value[col];
+						int index = _index[col];
+						float vx0 = _k[i];
+						float vx1 = 1.0f - vx0;
+						h0[index] += vx1 * vy1*value;
+						h1[index] += vx1 * vy0*value;
+						h0[Q2 + index] += vx0 * vy1*value;
+						h1[Q2 + index] += vx0 * vy0*value;
+					}
+					h0 += Q2;
+					h1 += Q2;
+				}
+			}
+
+			void EstimateHistogram(const uint8_t * src, size_t stride, size_t width, size_t height)
+			{
+				_histogram.Clear();
+				for (size_t row = 1; row < height - 1; ++row)
+				{
+					const uint8_t * src1 = src + stride * row;
+					const uint8_t * src0 = src1 - stride;
+					const uint8_t * src2 = src1 + stride;
+
+					for (size_t col = 1; col < width - 1; ++col)
+					{
+						float dy = (float)(src2[col] - src0[col]);
+						float dx = (float)(src1[col + 1] - src1[col - 1]);
+						float value = (float)::sqrt(dx*dx + dy * dy);
+						float ady = Simd::Abs(dy);
+						float adx = Simd::Abs(dx);
+
+						float bestDot = 0;
+						int index = 0;
+						for (int direction = 0; direction < 5; direction++)
+						{
+							float dot = _cos[direction] * adx + _sin[direction] * ady;
+							if (dot > bestDot)
+							{
+								bestDot = dot;
+								index = direction;
+							}
+						}
+						if (dx < 0)
+							index = Q - index;
+						if (dy < 0 && index != 0)
+							index = Q2 - index - (dx == 0);
+
+						_value[col] = value;
+						_index[col] = index;
+					}
+
+					AddRowToHistogram(row, width, height);
+				}
+			}
+
+			void EstimateNorm()
+			{
+				_norm.Clear();
+				for (size_t y = 0; y < _sy; ++y)
+				{
+					const float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					float * pn = _norm.data + (y + 1)*_hs + 1;
+					for (size_t x = 0; x < _sx; ++x)
+					{
+						const float * h = ph + x * Q2;
+						for (int o = 0; o < Q; ++o)
+							pn[x] += Simd::Square(h[o] + h[o + Q]);
+					}
+				}
+			}
+
+			void ExtractFeatures(float * features)
+			{
+				float eps = 0.0001f;
+				for (size_t y = 0; y < _sy; y++)
+				{
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 31;
+
+						float *psrc, n1, n2, n3, n4;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						n1 = 1.0f / sqrt(p1[1] + p1[2] + p2[1] + p2[2] + eps);
+						n2 = 1.0f / sqrt(p0[1] + p0[2] + p1[1] + p1[2] + eps);
+						n3 = 1.0f / sqrt(p1[0] + p1[1] + p2[0] + p2[1] + eps);
+						n4 = 1.0f / sqrt(p0[0] + p0[1] + p1[0] + p1[1] + eps);
+
+						float t1 = 0;
+						float t2 = 0;
+						float t3 = 0;
+						float t4 = 0;
+
+						psrc = _histogram.data + ((y + 1)*_hs + x + 1)*Q2;
+						for (int o = 0; o < Q2; o++)
+						{
+							float h1 = Simd::Min(*psrc * n1, 0.2f);
+							float h2 = Simd::Min(*psrc * n2, 0.2f);
+							float h3 = Simd::Min(*psrc * n3, 0.2f);
+							float h4 = Simd::Min(*psrc * n4, 0.2f);
+							*dst = 0.5f * (h1 + h2 + h3 + h4);
+							t1 += h1;
+							t2 += h2;
+							t3 += h3;
+							t4 += h4;
+							dst++;
+							psrc++;
+						}
+
+						psrc = _histogram.data + ((y + 1)*_hs + x + 1)*Q2;
+						for (int o = 0; o < Q; o++)
+						{
+							float sum = *psrc + *(psrc + Q);
+							float h1 = Simd::Min(sum * n1, 0.2f);
+							float h2 = Simd::Min(sum * n2, 0.2f);
+							float h3 = Simd::Min(sum * n3, 0.2f);
+							float h4 = Simd::Min(sum * n4, 0.2f);
+							*dst = 0.5f * (h1 + h2 + h3 + h4);
+							dst++;
+							psrc++;
+						}
+
+						*dst = 0.2357f * t1;
+						dst++;
+						*dst = 0.2357f * t2;
+						dst++;
+						*dst = 0.2357f * t3;
+						dst++;
+						*dst = 0.2357f * t4;
+					}
+				}
+			}
+
+			void ExtractFeatures22(float * features)
+			{
+				float eps = 0.0001f;
+				for (size_t y = 0; y < _sy; y++)
+				{
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 22;
+
+						float *psrc, n1, n2, n3, n4;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						n1 = 1.0f / sqrt(p1[1] + p1[2] + p2[1] + p2[2] + eps);
+						n2 = 1.0f / sqrt(p0[1] + p0[2] + p1[1] + p1[2] + eps);
+						n3 = 1.0f / sqrt(p1[0] + p1[1] + p2[0] + p2[1] + eps);
+						n4 = 1.0f / sqrt(p0[0] + p0[1] + p1[0] + p1[1] + eps);
+
+						float t1 = 0;
+						float t2 = 0;
+						float t3 = 0;
+						float t4 = 0;
+
+						psrc = _histogram.data + ((y + 1)*_hs + x + 1)*Q2;
+						for (int o = 0; o < Q2; o++)
+						{
+							float h1 = Simd::Min(*psrc * n1, 0.2f);
+							float h2 = Simd::Min(*psrc * n2, 0.2f);
+							float h3 = Simd::Min(*psrc * n3, 0.2f);
+							float h4 = Simd::Min(*psrc * n4, 0.2f);
+							*dst = 0.5f * (h1 + h2 + h3 + h4);
+							t1 += h1;
+							t2 += h2;
+							t3 += h3;
+							t4 += h4;
+							dst++;
+							psrc++;
+						}
+
+						*dst = 0.2357f * t1;
+						dst++;
+						*dst = 0.2357f * t2;
+						dst++;
+						*dst = 0.2357f * t3;
+						dst++;
+						*dst = 0.2357f * t4;
+					}
+				}
+			}
+
+		public:
+			void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int fet_len)
+			{
+				Init(width, height);
+
+				EstimateHistogram(src, stride, width, height);
+
+				EstimateNorm();
+
+				if(fet_len == 31)
+					ExtractFeatures(features);
+				else
+					ExtractFeatures22(features);
+			}
+		};
+
+        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len)
         {
-            assert(width % 8 == 0 && height % 8 == 0 && width >= 16 && height >= 16);
-
-            HogFeatureExtractor extractor;
-            extractor.Run(src, stride, width, height, features);
+			if (cell_size == 8) {
+				assert(width % cell_size == 0 && height % cell_size == 0 && width >= 16 && height >= 16);
+
+				HogFeatureExtractor extractor;
+				extractor.Run(src, stride, width, height, features, fet_len);
+			}
+			else {
+				assert(width % cell_size == 0 && height % cell_size == 0 && width >= 16 && height >= 16); 
+
+				HogFeatureExtractor4 extractor;
+				extractor.Run(src, stride, width, height, features, fet_len);
+			}
         }
 
         namespace HogSeparableFilter_Detail
diff --git a/src/Simd/SimdLib.cpp b/src/Simd/SimdLib.cpp
index 24fdccac..2ed94723 100644
--- a/src/Simd/SimdLib.cpp
+++ b/src/Simd/SimdLib.cpp
@@ -2514,29 +2514,29 @@ SIMD_API void SimdHogDirectionHistograms(const uint8_t * src, size_t stride, siz
         Base::HogDirectionHistograms(src, stride, width, height, cellX, cellY, quantization, histograms);
 }
 
-SIMD_API void SimdHogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
+SIMD_API void SimdHogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len)
 {
 #ifdef SIMD_AVX512BW_ENABLE
     if (Avx512bw::Enable && width >= Avx512bw::HA + 2)
-        Avx512bw::HogExtractFeatures(src, stride, width, height, features);
+        Avx512bw::HogExtractFeatures(src, stride, width, height, features, cell_size, fet_len);
     else
 #endif
 #ifdef SIMD_AVX2_ENABLE
     if (Avx2::Enable && width >= Avx2::HA + 2)
-        Avx2::HogExtractFeatures(src, stride, width, height, features);
+        Avx2::HogExtractFeatures(src, stride, width, height, features, cell_size, fet_len);
     else
 #endif
 #ifdef SIMD_SSE41_ENABLE
     if (Sse41::Enable && width >= Sse41::A + 2)
-        Sse41::HogExtractFeatures(src, stride, width, height, features);
+        Sse41::HogExtractFeatures(src, stride, width, height, features, cell_size, fet_len);
     else
 #endif
 #ifdef SIMD_NEON_ENABLE
     if (Neon::Enable && width >= Neon::A + 2)
-        Neon::HogExtractFeatures(src, stride, width, height, features);
+        Neon::HogExtractFeatures(src, stride, width, height, features, cell_size, fet_len);
     else
 #endif
-        Base::HogExtractFeatures(src, stride, width, height, features);
+        Base::HogExtractFeatures(src, stride, width, height, features, cell_size, fet_len);
 }
 
 SIMD_API void SimdHogDeinterleave(const float * src, size_t srcStride, size_t width, size_t height, size_t count, float ** dst, size_t dstStride)
diff --git a/src/Simd/SimdLib.h b/src/Simd/SimdLib.h
index b9892cb3..a3ac1c32 100644
--- a/src/Simd/SimdLib.h
+++ b/src/Simd/SimdLib.h
@@ -3018,7 +3018,7 @@ extern "C"
         \param [in] height - an image height. It must be a multiple of 8. Its minimal value is 16.
         \param [out] features - a pointer to buffer with features. Array must has size grater or equal to (width/8)*(height/8)*31.
     */
-    SIMD_API void SimdHogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features);
+    SIMD_API void SimdHogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len);
 
     /*! @ingroup hog
 
diff --git a/src/Simd/SimdNeon.h b/src/Simd/SimdNeon.h
index d57f4149..955c0c89 100644
--- a/src/Simd/SimdNeon.h
+++ b/src/Simd/SimdNeon.h
@@ -235,7 +235,7 @@ namespace Simd
         void HogDirectionHistograms(const uint8_t * src, size_t stride, size_t width, size_t height,
             size_t cellX, size_t cellY, size_t quantization, float * histograms);
 
-        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features);
+        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len);
 
         void HogFilterSeparable(const float * src, size_t srcStride, size_t width, size_t height, const float * rowFilter, size_t rowSize, const float * colFilter, size_t colSize, float * dst, size_t dstStride, int add);
 
diff --git a/src/Simd/SimdNeonHog.cpp b/src/Simd/SimdNeonHog.cpp
index bc033421..f9dced82 100644
--- a/src/Simd/SimdNeonHog.cpp
+++ b/src/Simd/SimdNeonHog.cpp
@@ -176,9 +176,9 @@ namespace Simd
             }
         }
 
-        class HogFeatureExtractor
+        class HogFeatureExtractor4
         {
-            static const size_t C = 8;
+            static const size_t C = 4;//adhi 8 to 4
             static const size_t Q = 9;
             static const size_t Q2 = 18;
 
@@ -189,7 +189,7 @@ namespace Simd
 
             int32x4_t _pos[5];
             float32x4_t _cos[5], _sin[5];
-            float32x4_t _kx[8], _ky[8];
+            float32x4_t _kx[4], _ky[4];//adhi resize to 4 from 8
             int32x4_t _Q, _Q2;
 
             Array32i _index;
@@ -211,7 +211,7 @@ namespace Simd
                 }
                 for (int i = 0; i < C; ++i)
                 {
-                    float k0 = float((15 - i * 2) / 16.0f);
+					float k0 = float((7 - i * 2) / 8.0f);;//float((15 - i * 2) / 16.0f); //adhi
                     float k1 = 1.0f - k0;
                     _kx[i] = SetF32(k0, k1, k0, k1);
                     _ky[i] = SetF32(k0, k0, k1, k1);
@@ -279,8 +279,8 @@ namespace Simd
                 GetHistogram<false>(s, stride, width - 1 - A);
 
                 float32x4_t * buffer = (float32x4_t*)_buffer.data;
-                float32x4_t ky = _ky[(row + 4) & 7];
-                for (size_t col = 1, n = C, i = 5; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))
+                float32x4_t ky = _ky[(row + 2) & 3];//_ky[(row + 4) & 7]; //adhi
+                for (size_t col = 1, n = C, i = 3; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1)) //adhi i = 5 to 3
                 {
                     for (; i < n; ++i, ++col)
                     {
@@ -327,7 +327,7 @@ namespace Simd
                 size_t aligned = AlignHi(width - 1, A) - A;
 
                 _buffer.Clear();
-                for (size_t row = 1; row < 4; ++row)
+                /*for (size_t row = 1; row < 4; ++row)
                     AddRowToBuffer(src, stride, row, width, aligned);
                 AddToHistogram(0, _sx, _sy);
                 for (size_t row = 4, cell = 1; row < height - 4; ++row)
@@ -338,7 +338,21 @@ namespace Simd
                 }
                 for (size_t row = height - 4; row < height - 1; ++row)
                     AddRowToBuffer(src, stride, row, width, aligned);
-                AddToHistogram(_sy, _sx, _sy);
+                AddToHistogram(_sy, _sx, _sy);*/
+
+				//adhi - Modified
+				for (size_t row = 1; row < 2; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(0, _sx, _sy);
+				for (size_t row = 2, cell = 1; row < height - 2; ++row)
+				{
+					AddRowToBuffer(src, stride, row, width, aligned);
+					if ((row & 3) == 1)
+						AddToHistogram(cell++, _sx, _sy);
+				}
+				for (size_t row = height - 2; row < height - 1; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(_sy, _sx, _sy);
             }
 
             SIMD_INLINE float GetNorm(const float * src)
@@ -436,9 +450,63 @@ namespace Simd
                 }
             }
 
+			void ExtractFeatures22(float * features)
+			{
+				float32x4_t _02 = vdupq_n_f32(0.2f);
+				float32x4_t _05 = vdupq_n_f32(0.5f);
+				float32x4_t _02357 = vdupq_n_f32(0.2357f);
+				float32x4_t eps = vdupq_n_f32(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 22;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						float32x4_t n = SetF32(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = ReciprocalSqrt<SIMD_NEON_RCP_ITER>(vaddq_f32(n, eps));
+
+						float32x4_t t = vdupq_n_f32(0);
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							float32x4_t s = Load<false>(src);
+							float32x4_t h0 = vminq_f32(vmulq_f32(Broadcast<0>(s), n), _02);
+							float32x4_t h1 = vminq_f32(vmulq_f32(Broadcast<1>(s), n), _02);
+							float32x4_t h2 = vminq_f32(vmulq_f32(Broadcast<2>(s), n), _02);
+							float32x4_t h3 = vminq_f32(vmulq_f32(Broadcast<3>(s), n), _02);
+							t = vaddq_f32(t, vaddq_f32(vaddq_f32(h0, h1), vaddq_f32(h2, h3)));
+							Store<false>(dst, vmulq_f32(_05, Hadd(Hadd(h0, h1), Hadd(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							float32x4_t h0 = vminq_f32(vmulq_f32(vdupq_n_f32(*src++), n), _02);
+							float32x4_t h1 = vminq_f32(vmulq_f32(vdupq_n_f32(*src++), n), _02);
+							t = vaddq_f32(t, vaddq_f32(h0, h1));
+							float32x4_t h = Hadd(h0, h1);
+							Store<false>(dst, vmulq_f32(_05, Hadd(h, h)));
+							dst += 2;
+						}
+
+						Store<false>(dst, vmulq_f32(t, _02357));
+					}
+				}
+			}
+
         public:
 
-            void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
+            void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int fet_len)
             {
                 Init(width, height);
 
@@ -446,16 +514,358 @@ namespace Simd
 
                 EstimateNorm();
 
-                ExtractFeatures(features);
+				if(fet_len == 31)
+					ExtractFeatures(features);
+				else
+					ExtractFeatures22(features);
             }
         };
 
-        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
+		class HogFeatureExtractor
+		{
+			static const size_t C = 8;
+			static const size_t Q = 9;
+			static const size_t Q2 = 18;
+
+			typedef Array<int> Array32i;
+			typedef Array<float> Array32f;
+
+			size_t _sx, _sy, _hs;
+
+			int32x4_t _pos[5];
+			float32x4_t _cos[5], _sin[5];
+			float32x4_t _kx[8], _ky[8];
+			int32x4_t _Q, _Q2;
+
+			Array32i _index;
+			Array32f _value;
+			Array32f _buffer;
+			Array32f _histogram;
+			Array32f _norm;
+
+			void Init(size_t w, size_t h)
+			{
+				_sx = w / C;
+				_hs = _sx + 2;
+				_sy = h / C;
+				for (int i = 0; i < 5; ++i)
+				{
+					_cos[i] = vdupq_n_f32((float)::cos(i*M_PI / Q));
+					_sin[i] = vdupq_n_f32((float)::sin(i*M_PI / Q));
+					_pos[i] = vdupq_n_s32(i);
+				}
+				for (int i = 0; i < C; ++i)
+				{
+					float k0 = float((15 - i * 2) / 16.0f); 
+					float k1 = 1.0f - k0;
+					_kx[i] = SetF32(k0, k1, k0, k1);
+					_ky[i] = SetF32(k0, k0, k1, k1);
+				}
+				_Q = vdupq_n_s32(Q);
+				_Q2 = vdupq_n_s32(Q2);
+
+				_index.Resize(w);
+				_value.Resize(w);
+				_buffer.Resize((_sx + 1) * 4 * Q2);
+				_histogram.Resize((_sx + 2)*(_sy + 2)*Q2);
+				_norm.Resize((_sx + 2)*(_sy + 2));
+			}
+
+			template <bool align> SIMD_INLINE void GetHistogram(const float32x4_t & dx, const float32x4_t & dy, size_t col)
+			{
+				float32x4_t _0 = vdupq_n_f32(0);
+				float32x4_t bestDot = _0;
+				int32x4_t bestIndex = vdupq_n_s32(0);
+				float32x4_t adx = vabsq_f32(dx);
+				float32x4_t ady = vabsq_f32(dy);
+				for (int i = 0; i < 5; ++i)
+				{
+					float32x4_t dot = vmlaq_f32(vmulq_f32(adx, _cos[i]), ady, _sin[i]);
+					uint32x4_t mask = vcgtq_f32(dot, bestDot);
+					bestDot = vmaxq_f32(dot, bestDot);
+					bestIndex = vbslq_s32(mask, _pos[i], bestIndex);
+				}
+				uint32x4_t maskDx = vcltq_f32(dx, _0);
+				bestIndex = vbslq_s32(maskDx, vsubq_s32(_Q, bestIndex), bestIndex);
+
+				uint32x4_t maskDy = vcltq_f32(dy, _0);
+				uint32x4_t corr = vandq_u32(vceqq_f32(adx, _0), K32_00000001);
+				bestIndex = vbslq_s32(maskDy, vsubq_s32(_Q2, vaddq_s32(bestIndex, (int32x4_t)corr)), bestIndex);
+
+				bestIndex = vbslq_s32(vceqq_s32(bestIndex, _Q2), (int32x4_t)K32_00000000, bestIndex);
+
+				Store<false>(_index.data + col, bestIndex); // fixed program crash.
+				Store<align>(_value.data + col, Sqrt<SIMD_NEON_RCP_ITER>(vmlaq_f32(vmulq_f32(adx, adx), ady, ady)));
+			}
+
+			template <bool align> SIMD_INLINE void GetHistogram(const int16x8_t & dx, const int16x8_t & dy, size_t col)
+			{
+				GetHistogram<align>(ToFloat<0>(dx), ToFloat<0>(dy), col + 0);
+				GetHistogram<align>(ToFloat<1>(dx), ToFloat<1>(dy), col + 4);
+			}
+
+			template <bool align> SIMD_INLINE void GetHistogram(const uint8_t * src, size_t stride, size_t col)
+			{
+				const uint8_t * s = src + col;
+				uint8x16_t t = Load<false>(s - stride);
+				uint8x16_t l = Load<false>(s - 1);
+				uint8x16_t r = Load<false>(s + 1);
+				uint8x16_t b = Load<false>(s + stride);
+				GetHistogram<align>(Sub<0>(r, l), Sub<0>(b, t), col + 0);
+				GetHistogram<align>(Sub<1>(r, l), Sub<1>(b, t), col + 8);
+			}
+
+			void AddRowToBuffer(const uint8_t * src, size_t stride, size_t row, size_t width, size_t aligned)
+			{
+				const uint8_t * s = src + stride * row;
+				GetHistogram<false>(s, stride, 1);
+				for (size_t col = A; col < aligned; col += A)
+					GetHistogram<true>(s, stride, col);
+				GetHistogram<false>(s, stride, width - 1 - A);
+
+				float32x4_t * buffer = (float32x4_t*)_buffer.data;
+				float32x4_t ky = _ky[(row + 4) & 7]; 
+				for (size_t col = 1, n = C, i = 5; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1)) 
+				{
+					for (; i < n; ++i, ++col)
+					{
+						int index = _index[col];
+						float32x4_t value = vdupq_n_f32(_value[col]);
+						buffer[index] = vmlaq_f32(buffer[index], value, vmulq_f32(ky, _kx[i]));
+					}
+					buffer += Q2;
+				}
+			}
+
+			void AddToHistogram(size_t row, size_t width, size_t height)
+			{
+				typedef float f18_t[18];
+				const float * src = _buffer.data;
+				f18_t * h0 = (f18_t*)_histogram.data + row * _hs;
+				f18_t * h1 = h0 + _hs;
+				for (size_t cell = 0; cell <= width; ++cell)
+				{
+					for (size_t i = 0; i < 16; i += 4)
+					{
+						float32x4x4_t s = Load4<true>(src + 4 * i);
+						Store<false>(h0[0] + i, vaddq_f32(Load<false>(h0[0] + i), s.val[0]));
+						Store<false>(h0[1] + i, vaddq_f32(Load<false>(h0[1] + i), s.val[1]));
+						Store<false>(h1[0] + i, vaddq_f32(Load<false>(h1[0] + i), s.val[2]));
+						Store<false>(h1[1] + i, vaddq_f32(Load<false>(h1[1] + i), s.val[3]));
+					}
+					float32x2x4_t s = LoadHalf4<true>(src + 64);
+					Store<false>(h0[0] + 16, vadd_f32(LoadHalf<false>(h0[0] + 16), s.val[0]));
+					Store<false>(h0[1] + 16, vadd_f32(LoadHalf<false>(h0[1] + 16), s.val[1]));
+					Store<false>(h1[0] + 16, vadd_f32(LoadHalf<false>(h1[0] + 16), s.val[2]));
+					Store<false>(h1[1] + 16, vadd_f32(LoadHalf<false>(h1[1] + 16), s.val[3]));
+					h0++;
+					h1++;
+					src += 4 * Q2;
+				}
+				_buffer.Clear();
+			}
+
+			void EstimateHistogram(const uint8_t * src, size_t stride, size_t width, size_t height)
+			{
+				_histogram.Clear();
+
+				size_t aligned = AlignHi(width - 1, A) - A;
+
+				_buffer.Clear();
+				for (size_t row = 1; row < 4; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(0, _sx, _sy);
+				for (size_t row = 4, cell = 1; row < height - 4; ++row)
+				{
+					AddRowToBuffer(src, stride, row, width, aligned);
+					if ((row & 7) == 3)
+						AddToHistogram(cell++, _sx, _sy);
+				}
+				for (size_t row = height - 4; row < height - 1; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(_sy, _sx, _sy);
+			}
+
+			SIMD_INLINE float GetNorm(const float * src)
+			{
+				float32x4_t norm = vdupq_n_f32(0);
+				for (size_t i = 0; i < 8; i += 4)
+				{
+					float32x4_t sum = vaddq_f32(Load<false>(src + i + 0), Load<false>(src + i + Q));
+					norm = vmlaq_f32(norm, sum, sum);
+				}
+				return ExtractSum32f(norm) + Simd::Square(src[Q - 1] + src[Q2 - 1]);
+			}
+
+			void EstimateNorm()
+			{
+				_norm.Clear();
+				for (size_t y = 0, i = 0; y < _sy; y++)
+				{
+					const float * h = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					float * n = _norm.data + (y + 1)*_hs + 1;
+					for (size_t x = 0; x < _sx; x++, i++)
+						n[x] = GetNorm(h + x * Q2);
+				}
+			}
+
+			void ExtractFeatures(float * features)
+			{
+				float32x4_t _02 = vdupq_n_f32(0.2f);
+				float32x4_t _05 = vdupq_n_f32(0.5f);
+				float32x4_t _02357 = vdupq_n_f32(0.2357f);
+				float32x4_t eps = vdupq_n_f32(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 31;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						float32x4_t n = SetF32(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = ReciprocalSqrt<SIMD_NEON_RCP_ITER>(vaddq_f32(n, eps));
+
+						float32x4_t t = vdupq_n_f32(0);
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							float32x4_t s = Load<false>(src);
+							float32x4_t h0 = vminq_f32(vmulq_f32(Broadcast<0>(s), n), _02);
+							float32x4_t h1 = vminq_f32(vmulq_f32(Broadcast<1>(s), n), _02);
+							float32x4_t h2 = vminq_f32(vmulq_f32(Broadcast<2>(s), n), _02);
+							float32x4_t h3 = vminq_f32(vmulq_f32(Broadcast<3>(s), n), _02);
+							t = vaddq_f32(t, vaddq_f32(vaddq_f32(h0, h1), vaddq_f32(h2, h3)));
+							Store<false>(dst, vmulq_f32(_05, Hadd(Hadd(h0, h1), Hadd(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							float32x4_t h0 = vminq_f32(vmulq_f32(vdupq_n_f32(*src++), n), _02);
+							float32x4_t h1 = vminq_f32(vmulq_f32(vdupq_n_f32(*src++), n), _02);
+							t = vaddq_f32(t, vaddq_f32(h0, h1));
+							float32x4_t h = Hadd(h0, h1);
+							Store<false>(dst, vmulq_f32(_05, Hadd(h, h)));
+							dst += 2;
+						}
+
+						src = ph + x * Q2;
+						for (int o = 0; o < 8; o += 4)
+						{
+							float32x4_t s = vaddq_f32(Load<false>(src), Load<false>(src + Q));
+							float32x4_t h0 = vminq_f32(vmulq_f32(Broadcast<0>(s), n), _02);
+							float32x4_t h1 = vminq_f32(vmulq_f32(Broadcast<1>(s), n), _02);
+							float32x4_t h2 = vminq_f32(vmulq_f32(Broadcast<2>(s), n), _02);
+							float32x4_t h3 = vminq_f32(vmulq_f32(Broadcast<3>(s), n), _02);
+							Store<false>(dst, vmulq_f32(_05, Hadd(Hadd(h0, h1), Hadd(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							float32x4_t s = vdupq_n_f32(src[0] + src[Q]);
+							float32x4_t h = vminq_f32(vmulq_f32(s, n), _02);
+							h = vmulq_f32(_05, h);
+							*dst++ = ExtractSum32f(h);
+						}
+						Store<false>(dst, vmulq_f32(t, _02357));
+					}
+				}
+			}
+
+			void ExtractFeatures22(float * features)
+			{
+				float32x4_t _02 = vdupq_n_f32(0.2f);
+				float32x4_t _05 = vdupq_n_f32(0.5f);
+				float32x4_t _02357 = vdupq_n_f32(0.2357f);
+				float32x4_t eps = vdupq_n_f32(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 22;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						float32x4_t n = SetF32(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = ReciprocalSqrt<SIMD_NEON_RCP_ITER>(vaddq_f32(n, eps));
+
+						float32x4_t t = vdupq_n_f32(0);
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							float32x4_t s = Load<false>(src);
+							float32x4_t h0 = vminq_f32(vmulq_f32(Broadcast<0>(s), n), _02);
+							float32x4_t h1 = vminq_f32(vmulq_f32(Broadcast<1>(s), n), _02);
+							float32x4_t h2 = vminq_f32(vmulq_f32(Broadcast<2>(s), n), _02);
+							float32x4_t h3 = vminq_f32(vmulq_f32(Broadcast<3>(s), n), _02);
+							t = vaddq_f32(t, vaddq_f32(vaddq_f32(h0, h1), vaddq_f32(h2, h3)));
+							Store<false>(dst, vmulq_f32(_05, Hadd(Hadd(h0, h1), Hadd(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							float32x4_t h0 = vminq_f32(vmulq_f32(vdupq_n_f32(*src++), n), _02);
+							float32x4_t h1 = vminq_f32(vmulq_f32(vdupq_n_f32(*src++), n), _02);
+							t = vaddq_f32(t, vaddq_f32(h0, h1));
+							float32x4_t h = Hadd(h0, h1);
+							Store<false>(dst, vmulq_f32(_05, Hadd(h, h)));
+							dst += 2;
+						}
+
+						Store<false>(dst, vmulq_f32(t, _02357));
+					}
+				}
+			}
+
+		public:
+
+			void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int fet_len)
+			{
+				Init(width, height);
+
+				EstimateHistogram(src, stride, width, height);
+
+				EstimateNorm();
+
+				if(fet_len == 31)
+					ExtractFeatures(features);
+				else
+					ExtractFeatures22(features);
+			}
+		};
+
+        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len)
         {
-            assert(width % 8 == 0 && height % 8 == 0 && width >= 16 && height >= 16);
-
-            HogFeatureExtractor extractor;
-            extractor.Run(src, stride, width, height, features);
+			if (cell_size == 8) {
+				assert(width % cell_size == 0 && height % cell_size == 0 && width >= 16 && height >= 16); //adhi changed from 8 to 4
+
+				HogFeatureExtractor extractor;
+				extractor.Run(src, stride, width, height, features, fet_len);
+			}
+			else if (cell_size == 4) {
+				assert(width % cell_size == 0 && height % cell_size == 0 && width >= 16 && height >= 16); //adhi changed from 8 to 4
+
+				HogFeatureExtractor4 extractor;
+				extractor.Run(src, stride, width, height, features, fet_len);
+			}
         }
 
         namespace HogSeparableFilter_Detail
diff --git a/src/Simd/SimdSse41.h b/src/Simd/SimdSse41.h
index 2f778ae9..6c2c5b0e 100644
--- a/src/Simd/SimdSse41.h
+++ b/src/Simd/SimdSse41.h
@@ -51,7 +51,7 @@ namespace Simd
 
         void HogDirectionHistograms(const uint8_t * src, size_t stride, size_t width, size_t height, size_t cellX, size_t cellY, size_t quantization, float * histograms);
 
-        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features);
+        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len);
 
         void HogLiteExtractFeatures(const uint8_t * src, size_t srcStride, size_t width, size_t height, size_t cell, float * features, size_t featuresStride);
 
diff --git a/src/Simd/SimdSse41Hog.cpp b/src/Simd/SimdSse41Hog.cpp
index 0b48248b..c14f0c34 100644
--- a/src/Simd/SimdSse41Hog.cpp
+++ b/src/Simd/SimdSse41Hog.cpp
@@ -301,9 +301,9 @@ namespace Simd
                 Sse2::HogDirectionHistograms(src, stride, width, height, cellX, cellY, quantization, histograms);
         }
 
-        class HogFeatureExtractor
+        class HogFeatureExtractor4
         {
-            static const size_t C = 8;
+            static const size_t C = 4; //adhi 8 to 4
             static const size_t Q = 9;
             static const size_t Q2 = 18;
 
@@ -311,7 +311,7 @@ namespace Simd
 
             __m128i _pos[5];
             __m128 _cos[5], _sin[5];
-            __m128 _kx[8], _ky[8];
+            __m128 _kx[4], _ky[4];//adhi resize to 4 from 8
             __m128i _Q, _Q2;
 
             Array32i _index;
@@ -333,7 +333,7 @@ namespace Simd
                 }
                 for (int i = 0; i < C; ++i)
                 {
-                    float k0 = float((15 - i * 2) / 16.0f);
+                    float k0 = float((7 - i * 2) / 8.0f);// float((15 - i * 2) / 16.0f); adhi
                     float k1 = 1.0f - k0;
                     _kx[i] = _mm_setr_ps(k0, k1, k0, k1);
                     _ky[i] = _mm_setr_ps(k0, k0, k1, k1);
@@ -401,8 +401,8 @@ namespace Simd
                 GetHistogram<false>(s, stride, width - 1 - A);
 
                 __m128 * buffer = (__m128*)_buffer.data;
-                __m128 ky = _ky[(row + 4) & 7];
-                for (size_t col = 1, n = C, i = 5; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))
+                __m128 ky = _ky[(row + 2) & 3]; //_ky[(row + 4) & 7]; //adhi
+                for (size_t col = 1, n = C, i = 3; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))//adhi i = 5 to 3
                 {
                     for (; i < n; ++i, ++col)
                     {
@@ -455,7 +455,8 @@ namespace Simd
                 size_t aligned = AlignHi(width - 1, A) - A;
 
                 _buffer.Clear();
-                for (size_t row = 1; row < 4; ++row)
+
+                /*for (size_t row = 1; row < 4; ++row)
                     AddRowToBuffer(src, stride, row, width, aligned);
                 AddToHistogram(0, _sx, _sy);
                 for (size_t row = 4, cell = 1; row < height - 4; ++row)
@@ -466,7 +467,21 @@ namespace Simd
                 }
                 for (size_t row = height - 4; row < height - 1; ++row)
                     AddRowToBuffer(src, stride, row, width, aligned);
-                AddToHistogram(_sy, _sx, _sy);
+                AddToHistogram(_sy, _sx, _sy);*/
+
+				//adhi - Modified
+				for (size_t row = 1; row < 2; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(0, _sx, _sy);
+				for (size_t row = 2, cell = 1; row < height - 2; ++row)
+				{
+					AddRowToBuffer(src, stride, row, width, aligned);
+					if ((row & 3) == 1)
+						AddToHistogram(cell++, _sx, _sy);
+				}
+				for (size_t row = height - 2; row < height - 1; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(_sy, _sx, _sy);
             }
 
             SIMD_INLINE float GetNorm(const float * src)
@@ -568,9 +583,63 @@ namespace Simd
                 }
             }
 
+			void ExtractFeatures22(float * features)
+			{
+				__m128 _02 = _mm_set1_ps(0.2f);
+				__m128 _05 = _mm_set1_ps(0.5f);
+				__m128 _02357 = _mm_set1_ps(0.2357f);
+				__m128 eps = _mm_set1_ps(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 22;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						__m128 n = _mm_setr_ps(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = _mm_rsqrt_ps(_mm_add_ps(n, eps));
+
+						__m128 t = _mm_setzero_ps();
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							__m128 s = _mm_loadu_ps(src);
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Broadcast<3>(s), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(_mm_add_ps(h0, h1), _mm_add_ps(h2, h3)));
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(h0, h1));
+							__m128 h = _mm_hadd_ps(h0, h1);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(h, h)));
+							dst += 2;
+						}
+
+						_mm_storeu_ps(dst, _mm_mul_ps(t, _02357));
+					}
+				}
+			}
+
         public:
 
-            void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
+            void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int fet_len)
             {
                 Init(width, height);
 
@@ -578,17 +647,367 @@ namespace Simd
 
                 EstimateNorm();
 
-                ExtractFeatures(features);
+				if(fet_len == 31)
+					ExtractFeatures(features);
+				else
+					ExtractFeatures22(features);
             }
         };
 
-        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features)
+		class HogFeatureExtractor
+		{
+			static const size_t C = 8;
+			static const size_t Q = 9;
+			static const size_t Q2 = 18;
+
+			size_t _sx, _sy, _hs;
+
+			__m128i _pos[5];
+			__m128 _cos[5], _sin[5];
+			__m128 _kx[8], _ky[8];
+			__m128i _Q, _Q2;
+
+			Array32i _index;
+			Array32f _value;
+			Array32f _buffer;
+			Array32f _histogram;
+			Array32f _norm;
+
+			void Init(size_t w, size_t h)
+			{
+				_sx = w / C;
+				_hs = _sx + 2;
+				_sy = h / C;
+				for (int i = 0; i < 5; ++i)
+				{
+					_cos[i] = _mm_set1_ps((float)::cos(i*M_PI / Q));
+					_sin[i] = _mm_set1_ps((float)::sin(i*M_PI / Q));
+					_pos[i] = _mm_set1_epi32(i);
+				}
+				for (int i = 0; i < C; ++i)
+				{
+					float k0 = float((15 - i * 2) / 16.0f);
+					float k1 = 1.0f - k0;
+					_kx[i] = _mm_setr_ps(k0, k1, k0, k1);
+					_ky[i] = _mm_setr_ps(k0, k0, k1, k1);
+				}
+				_Q = _mm_set1_epi32(Q);
+				_Q2 = _mm_set1_epi32(Q2);
+
+				_index.Resize(w);
+				_value.Resize(w);
+				_buffer.Resize((_sx + 1) * 4 * Q2);
+				_histogram.Resize((_sx + 2)*(_sy + 2)*Q2);
+				_norm.Resize((_sx + 2)*(_sy + 2));
+			}
+
+			template <bool align> SIMD_INLINE void GetHistogram(const __m128 & dx, const __m128 & dy, size_t col)
+			{
+				__m128 _0 = _mm_set1_ps(-0.0f);
+				__m128 adx = _mm_andnot_ps(_0, dx);
+				__m128 ady = _mm_andnot_ps(_0, dy);
+				__m128 bestDot = _mm_add_ps(_mm_mul_ps(adx, _cos[0]), _mm_mul_ps(ady, _sin[0]));
+				__m128i bestIndex = _pos[0];
+				for (int i = 1; i < 5; ++i)
+				{
+					__m128 dot = _mm_add_ps(_mm_mul_ps(adx, _cos[i]), _mm_mul_ps(ady, _sin[i]));
+					__m128 mask = _mm_cmpgt_ps(dot, bestDot);
+					bestDot = _mm_max_ps(dot, bestDot);
+					bestIndex = _mm_blendv_epi8(bestIndex, _pos[i], _mm_castps_si128(mask));
+				}
+				__m128i maskDx = _mm_castps_si128(_mm_cmplt_ps(dx, _mm_setzero_ps()));
+				bestIndex = _mm_blendv_epi8(bestIndex, _mm_sub_epi32(_Q, bestIndex), maskDx);
+
+				__m128i maskDy = _mm_castps_si128(_mm_cmplt_ps(dy, _mm_setzero_ps()));
+				__m128i corr = _mm_and_si128(_mm_castps_si128(_mm_cmpeq_ps(adx, _mm_setzero_ps())), K32_00000001);
+				bestIndex = _mm_blendv_epi8(bestIndex, _mm_sub_epi32(_Q2, _mm_add_epi32(bestIndex, corr)), maskDy);
+
+				bestIndex = _mm_andnot_si128(_mm_cmpeq_epi32(bestIndex, _Q2), bestIndex);
+
+				Store<align>((__m128i*)(_index.data + col), bestIndex);
+				Sse::Store<align>(_value.data + col, Sse::Sqrt<0>(_mm_add_ps(_mm_mul_ps(adx, adx), _mm_mul_ps(ady, ady))));
+			}
+
+			template <bool align> SIMD_INLINE void GetHistogram(const __m128i & dx, const __m128i & dy, size_t col)
+			{
+				GetHistogram<align>(_mm_cvtepi32_ps(UnpackI16<0>(dx)), _mm_cvtepi32_ps(UnpackI16<0>(dy)), col + 0);
+				GetHistogram<align>(_mm_cvtepi32_ps(UnpackI16<1>(dx)), _mm_cvtepi32_ps(UnpackI16<1>(dy)), col + 4);
+			}
+
+			template <bool align> SIMD_INLINE void GetHistogram(const uint8_t * src, size_t stride, size_t col)
+			{
+				const uint8_t * s = src + col;
+				__m128i t = Load<false>((__m128i*)(s - stride));
+				__m128i l = Load<false>((__m128i*)(s - 1));
+				__m128i r = Load<false>((__m128i*)(s + 1));
+				__m128i b = Load<false>((__m128i*)(s + stride));
+				GetHistogram<align>(SubUnpackedU8<0>(r, l), SubUnpackedU8<0>(b, t), col + 0);
+				GetHistogram<align>(SubUnpackedU8<1>(r, l), SubUnpackedU8<1>(b, t), col + 8);
+			}
+
+			void AddRowToBuffer(const uint8_t * src, size_t stride, size_t row, size_t width, size_t aligned)
+			{
+				const uint8_t * s = src + stride * row;
+				GetHistogram<false>(s, stride, 1);
+				for (size_t col = A; col < aligned; col += A)
+					GetHistogram<true>(s, stride, col);
+				GetHistogram<false>(s, stride, width - 1 - A);
+
+				__m128 * buffer = (__m128*)_buffer.data;
+				__m128 ky = _ky[(row + 4) & 7];
+				for (size_t col = 1, n = C, i = 5; col < width - 1; i = 0, n = Simd::Min<size_t>(C, width - col - 1))
+				{
+					for (; i < n; ++i, ++col)
+					{
+						int index = _index[col];
+						__m128 value = _mm_set1_ps(_value[col]);
+						buffer[index] = _mm_add_ps(buffer[index], _mm_mul_ps(value, _mm_mul_ps(ky, _kx[i])));
+					}
+					buffer += Q2;
+				}
+			}
+
+			void AddToHistogram(size_t row, size_t width, size_t height)
+			{
+				typedef float f18_t[18];
+				float * src = _buffer.data;
+				f18_t * h0 = (f18_t*)_histogram.data + row * _hs;
+				f18_t * h1 = h0 + _hs;
+				for (size_t cell = 0; cell <= width; ++cell)
+				{
+					__m128 * ps = (__m128*)src;
+					for (size_t i = 0; i < 16; i += 4)
+					{
+						__m128 s00 = _mm_unpacklo_ps(ps[i + 0], ps[i + 2]);
+						__m128 s01 = _mm_unpacklo_ps(ps[i + 1], ps[i + 3]);
+						__m128 s10 = _mm_unpackhi_ps(ps[i + 0], ps[i + 2]);
+						__m128 s11 = _mm_unpackhi_ps(ps[i + 1], ps[i + 3]);
+
+						_mm_storeu_ps(h0[0] + i, _mm_add_ps(_mm_loadu_ps(h0[0] + i), _mm_unpacklo_ps(s00, s01)));
+						_mm_storeu_ps(h0[1] + i, _mm_add_ps(_mm_loadu_ps(h0[1] + i), _mm_unpackhi_ps(s00, s01)));
+						_mm_storeu_ps(h1[0] + i, _mm_add_ps(_mm_loadu_ps(h1[0] + i), _mm_unpacklo_ps(s10, s11)));
+						_mm_storeu_ps(h1[1] + i, _mm_add_ps(_mm_loadu_ps(h1[1] + i), _mm_unpackhi_ps(s10, s11)));
+					}
+					__m128 s0 = _mm_add_ps(_mm_unpacklo_ps(ps[16], ps[17]), Sse::Load(h0[0] + 16, h0[1] + 16));
+					__m128 s1 = _mm_add_ps(_mm_unpackhi_ps(ps[16], ps[17]), Sse::Load(h1[0] + 16, h1[1] + 16));
+					Sse::StoreHalf<0>(h0[0] + 16, s0);
+					Sse::StoreHalf<1>(h0[1] + 16, s0);
+					Sse::StoreHalf<0>(h1[0] + 16, s1);
+					Sse::StoreHalf<1>(h1[1] + 16, s1);
+					h0++;
+					h1++;
+					src += 4 * Q2;
+				}
+				_buffer.Clear();
+			}
+
+			void EstimateHistogram(const uint8_t * src, size_t stride, size_t width, size_t height)
+			{
+				_histogram.Clear();
+
+				size_t aligned = AlignHi(width - 1, A) - A;
+
+				_buffer.Clear();
+
+				for (size_t row = 1; row < 4; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(0, _sx, _sy);
+				for (size_t row = 4, cell = 1; row < height - 4; ++row)
+				{
+					AddRowToBuffer(src, stride, row, width, aligned);
+					if ((row & 7) == 3)
+						AddToHistogram(cell++, _sx, _sy);
+				}
+				for (size_t row = height - 4; row < height - 1; ++row)
+					AddRowToBuffer(src, stride, row, width, aligned);
+				AddToHistogram(_sy, _sx, _sy);
+			}
+
+			SIMD_INLINE float GetNorm(const float * src)
+			{
+				__m128 _norm = _mm_setzero_ps();
+				for (size_t i = 0; i < 8; i += 4)
+				{
+					__m128 sum = _mm_add_ps(_mm_loadu_ps(src + i + 0), _mm_loadu_ps(src + i + Q));
+					_norm = _mm_add_ps(_norm, _mm_mul_ps(sum, sum));
+				}
+				_norm = _mm_hadd_ps(_norm, _norm);
+				_norm = _mm_hadd_ps(_norm, _norm);
+				float norm;
+				_mm_store_ss(&norm, _norm);
+				return norm + Simd::Square(src[Q - 1] + src[Q2 - 1]);
+			}
+
+			void EstimateNorm()
+			{
+				_norm.Clear();
+				for (size_t y = 0, i = 0; y < _sy; y++)
+				{
+					const float * h = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					float * n = _norm.data + (y + 1)*_hs + 1;
+					for (size_t x = 0; x < _sx; x++, i++)
+						n[x] = GetNorm(h + x * Q2);
+				}
+			}
+
+			void ExtractFeatures(float * features)
+			{
+				__m128 _02 = _mm_set1_ps(0.2f);
+				__m128 _05 = _mm_set1_ps(0.5f);
+				__m128 _02357 = _mm_set1_ps(0.2357f);
+				__m128 eps = _mm_set1_ps(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 31;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						__m128 n = _mm_setr_ps(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = _mm_rsqrt_ps(_mm_add_ps(n, eps));
+
+						__m128 t = _mm_setzero_ps();
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							__m128 s = _mm_loadu_ps(src);
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Broadcast<3>(s), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(_mm_add_ps(h0, h1), _mm_add_ps(h2, h3)));
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(h0, h1));
+							__m128 h = _mm_hadd_ps(h0, h1);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(h, h)));
+							dst += 2;
+						}
+
+						src = ph + x * Q2;
+						for (int o = 0; o < 8; o += 4)
+						{
+							__m128 s = _mm_add_ps(_mm_loadu_ps(src), _mm_loadu_ps(src + Q));
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Broadcast<3>(s), n), _02);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 s = _mm_set1_ps(src[0] + src[Q]);
+							__m128 h = _mm_min_ps(_mm_mul_ps(s, n), _02);
+							h = _mm_dp_ps(_05, h, 0xF1);
+							_mm_store_ss(dst++, h);
+						}
+						_mm_storeu_ps(dst, _mm_mul_ps(t, _02357));
+					}
+				}
+			}
+
+			void ExtractFeatures22(float * features)
+			{
+				__m128 _02 = _mm_set1_ps(0.2f);
+				__m128 _05 = _mm_set1_ps(0.5f);
+				__m128 _02357 = _mm_set1_ps(0.2357f);
+				__m128 eps = _mm_set1_ps(0.0001f);
+				for (size_t y = 0; y < _sy; y++)
+				{
+					float * ph = _histogram.data + ((y + 1)*_hs + 1)*Q2;
+					for (size_t x = 0; x < _sx; x++)
+					{
+						float * dst = features + (y*_sx + x) * 22;
+
+						float * p0 = _norm.data + y * _hs + x;
+						float * p1 = p0 + _hs;
+						float * p2 = p1 + _hs;
+
+						__m128 n = _mm_setr_ps(
+							p1[1] + p1[2] + p2[1] + p2[2],
+							p0[1] + p0[2] + p1[1] + p1[2],
+							p1[0] + p1[1] + p2[0] + p2[1],
+							p0[0] + p0[1] + p1[0] + p1[1]);
+
+						n = _mm_rsqrt_ps(_mm_add_ps(n, eps));
+
+						__m128 t = _mm_setzero_ps();
+
+						float * src = ph + x * Q2;
+						for (int o = 0; o < 16; o += 4)
+						{
+							__m128 s = _mm_loadu_ps(src);
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(Broadcast<0>(s), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(Broadcast<1>(s), n), _02);
+							__m128 h2 = _mm_min_ps(_mm_mul_ps(Broadcast<2>(s), n), _02);
+							__m128 h3 = _mm_min_ps(_mm_mul_ps(Broadcast<3>(s), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(_mm_add_ps(h0, h1), _mm_add_ps(h2, h3)));
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(_mm_hadd_ps(h0, h1), _mm_hadd_ps(h2, h3))));
+							dst += 4;
+							src += 4;
+						}
+						{
+							__m128 h0 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							__m128 h1 = _mm_min_ps(_mm_mul_ps(_mm_set1_ps(*src++), n), _02);
+							t = _mm_add_ps(t, _mm_add_ps(h0, h1));
+							__m128 h = _mm_hadd_ps(h0, h1);
+							_mm_storeu_ps(dst, _mm_mul_ps(_05, _mm_hadd_ps(h, h)));
+							dst += 2;
+						}
+						_mm_storeu_ps(dst, _mm_mul_ps(t, _02357));
+					}
+				}
+			}
+
+		public:
+
+			void Run(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int fet_len)
+			{
+				Init(width, height);
+
+				EstimateHistogram(src, stride, width, height);
+
+				EstimateNorm();
+
+				if (fet_len == 31)
+					ExtractFeatures(features);
+				else
+					ExtractFeatures22(features);
+			}
+		};
+
+        void HogExtractFeatures(const uint8_t * src, size_t stride, size_t width, size_t height, float * features, int cell_size, int fet_len)
         {
-            assert(width % 8 == 0 && height % 8 == 0 && width >= 16 && height >= 16);
-            assert(width >= A + 2);
-
-            HogFeatureExtractor extractor;
-            extractor.Run(src, stride, width, height, features);
+			if (cell_size == 8) {
+				assert(width % cell_size == 0 && height % cell_size == 0 && width >= 16 && height >= 16);
+				assert(width >= A + 2);
+
+				HogFeatureExtractor extractor;
+				extractor.Run(src, stride, width, height, features, fet_len);
+			}
+			else if (cell_size == 4) {
+				assert(width % cell_size == 0 && height % cell_size == 0 && width >= 16 && height >= 16);
+				assert(width >= A + 2);
+
+				HogFeatureExtractor4 extractor;
+				extractor.Run(src, stride, width, height, features, fet_len);
+			}
         }
     }
 #endif// SIMD_SSE41_ENABLE
-- 
2.17.1

